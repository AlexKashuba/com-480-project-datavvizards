<!DOCTYPE html>
<meta charset="utf-8">
<link href="https://fonts.googleapis.com/css2?family=Open+Sans:wght@600&display=swap" rel="stylesheet">
<style>
    /* set the CSS */

    body {
        background-color: rgb(34, 37, 45);
    }

    text {
        paint-order: stroke;
        stroke: rgb(34, 37, 45);
        stroke-linecap: butt;
        stroke-linejoin: miter;
        font-weight: 600;
        font-family: 'Open Sans', sans-serif;
    }

    label {
        color: white;
        font-family: 'Open Sans', sans-serif;
    }
</style>

<body>
    <div>
        <label for="city">Search city:</label>
        <input type="text" id="city_name" name="city">
        <button type="button" id="search_city">Search</button>
    </div>
    <div id="chart"></div>
    <!-- <svg id="citiesSVG"> -->
    <!-- </svg> -->
    </div>

    <!-- load the d3.js library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/5.16.0/d3.min.js"></script>
    <script>


        // set the dimensions and margins of the graph
        var margin = { top: 200, right: 100, bottom: 100, left: 300 },
            width = window.innerWidth,
            height = window.innerHeight - 100;

        // Register the "custom" namespace prefix for our custom elements.
        // d3.ns.prefix.custom = "https://d3js.org/namespace/custom";

        // set the ranges
        var x = d3.scaleLinear().range([0, width]);
        var y = d3.scaleLinear().range([height, 0]);

        // var svg = d3.select("#chart").append("svg")
        var svg = d3.create("svg")
            .attr("width", width)
            .attr("height", height)
            .attr("display", "none");

        const gDotsBlur = svg.append("g");
        const gDots = svg.append("g").attr("id", "dots");
        const gLabels = svg.append("g");
        const zoomExtent = [0.7, 32];
        const labelExtent = [1, 10];
        const baseFontSize = 15;
        const strokeWidth = 0;
        const labelOffsetX = -20;
        const labelOffsetY = -8;
        const initialScale = 0.7;

        function labelXOffset(d, k) {
            return - d.city.length * baseFontSize / 4 / k;
        }

        d3.csv("embedding_cities.csv").then(function (data) {

            //Create the visible canvas and context
            var canvas = d3.select("#chart").append("canvas")
                .attr("id", "canvas")
                .attr("width", width)
                .attr("height", height);

            var context = canvas.node().getContext("2d");

            const blurCanvas = document.createElement('canvas');
            const blurContext = blurCanvas.getContext('2d');
            blurCanvas.width = width;
            blurCanvas.height = height;

            const labelScale = d3.scaleLinear().range(labelExtent).domain(d3.extent(data, (d) => +d.rank));
            const ex = d3.extent(data, (d) => +d.population);
            const populationRadius = d3.scaleLinear().domain(ex).range([3, 10]);

            data.forEach(function (d) {
                d.population = +d.population;
                d.radius = populationRadius(d.population);
                d.rank = +d.rank;
                d.x = +d.x;
                d.y = +d.y;
                d.geohash_norm = +d.geohash_norm;
                d.scale = labelScale(d.rank);
            });

            // Scale the range of the data
            x.domain(d3.extent(data, (d) => +d.x));
            y.domain(d3.extent(data, (d) => +d.y));

            const search = document.getElementById("search_city")
            search.onclick = findCoords;

            const myColor = d3.scaleSequential().domain([0, 1])
                .interpolator(d3.interpolateSpectral);

            // gDots.attr("stroke-width", strokeWidth).attr("font-size", baseFontSize).attr("fill", "white")
            //     .selectAll("text")
            //     .data(data)
            //     .join("text")
            //     .attr("x", d => x(d.x) + labelXOffset(d, initialScale)) //labelOffsetX)
            //     .attr("y", d => y(d.y) + labelOffsetY)
            //     .attr("text-rendering", "optimizeSpeed")
            //     .attr("display", "none")
            //     .text(d => d.city);
            // svg.call(zoom).call(zoom.transform, d3.zoomIdentity);



            // function zoomed() {
            //     const transform = d3.event.transform;
            //     gDots.attr("transform", transform);
            //     gDotsBlur.attr("transform", transform);
            //     gDots.selectAll("circle")
            //         .data(data)
            //         .attr("r", (d) => d.radius / transform.k);
            //     gDots.attr("font-size", Math.max(12 / transform.k, baseFontSize / (Math.pow(transform.k, 1.8))));
            //     gDots.attr("stroke-width", strokeWidth / transform.k);
            //     gDots.selectAll("text").data(data)
            //         .attr("x", d => x(d.x) + labelXOffset(d, transform.k))
            //         .attr("y", d => y(d.y) + labelOffsetY / transform.k)
            //         .attr("display",
            //             (d) => d.rank < 11 || d.scale <= transform.k ? "inline" : "none"
            //         )
            // }

            var currentK = initialScale;

            let blurScale = d3.scalePow().range([10, 5]).domain(labelExtent);

            function zoomCanvas(transform) {
                currentK = transform.k;
                window.requestAnimationFrame(function () {
                    context.clearRect(0, 0, width, height);

                    blurContext.save();
                    blurContext.clearRect(0, 0, width, height);
                    blurContext.translate(transform.x, transform.y);
                    blurContext.scale(transform.k, transform.k);

                    for (let d of data) {
                        drawPoint(d);
                    }

                    // console.log(`${x.invert(transform.x / transform.k)}, ${y.invert(transform.y / transform.k)}`)
                    // blurContext.fill();
                    // let filter = `blur(${blurScale(transform.k)}px) saturate(120%) brightness(120%) `;
                    // context.filter =filter;
                    // context.drawImage(blurCanvas, 0, 0);
                    // context.filter = "blur(0px) saturate(100%) brightness(100%)";
                    context.drawImage(blurCanvas, 0, 0);
                    
                    blurContext.restore();

                    context.save();
                    context.translate(transform.x, transform.y);
                    context.scale(transform.k, transform.k);

                    for (let d of data) {
                        drawLabel(d);
                    }
                    // context.fill();
                    context.restore();
                });
            }

            function redraw() {
                for (let d of data) {
                    drawPoint(d);
                }
                context.drawImage(blurCanvas, 0, 0);
                for (let d of data) {
                    drawLabel(d);
                }
            }

            // For now we only support circles with strokeStyle.
            // But you should imagine extending this to arbitrary shapes and groups!
            function drawPoint(d) {
                blurContext.beginPath();
                blurContext.arc(x(d.x), y(d.y), d.radius / currentK, 0, 2 * Math.PI);
                blurContext.fillStyle = myColor(d.geohash_norm);
                blurContext.fill();
            }

            function drawLabel(d) {
                let fontSize = Math.max(12 / currentK, baseFontSize / (Math.pow(currentK, 1.8)));
                context.font = `${fontSize}px Open Sans`;

                if (d.rank < 11 || d.scale <= currentK) {
                    context.fillStyle = "white"
                    context.fillText(d.city, x(d.x), y(d.y));
                }
            }

            var root = this;
            canvas.style.position = "absolute";
            canvas.style.top = root.offsetTop + "px";
            canvas.style.left = root.offsetLeft + "px";
            context.font = "10px Open Sans"

            function custom(selection) {
                selection.each(function () {
                    redraw();
                });
            }

            document.body.onkeydown = function (e) {
                if (e.keyCode == 13)
                    findCoords();
            };

            const zoom = d3.zoom()
                .scaleExtent(zoomExtent)
                .on("zoom", () => zoomCanvas(d3.event.transform));

            function findCoords() {
                const searchField = document.getElementById("city_name");
                const name = searchField.value.toLowerCase();
                var city = null;
                for (d of data) {
                    if (d.city.toLowerCase() === name) {
                        city = d;
                        break;
                    }
                }

                if (city) {
                    d3.select(context.canvas).transition().duration(750).call(
                        zoom.transform,
                        d3.zoomIdentity.translate(width / 2, height / 2).scale(10).translate(-x(city.x), -y(city.y))
                    );
                }
            }

            d3.select(context.canvas).call(zoom);
            zoom.scaleTo(canvas, initialScale);
            redraw()

        });


    </script>
</body>
<!DOCTYPE html>
<meta charset="utf-8">
<link href="https://fonts.googleapis.com/css2?family=Open+Sans:wght@600&display=swap" rel="stylesheet">
<style>
    /* set the CSS */

    body {
        background-color: rgb(34, 37, 45);
    }

    text {
        paint-order: stroke;
        stroke: rgb(34, 37, 45);
        stroke-linecap: butt;
        stroke-linejoin: miter;
        font-weight: 600;
        font-family: 'Open Sans', sans-serif;
    }

    label {
        color: white;
        font-family: 'Open Sans', sans-serif;
    }

    #viz {
        display: flex;
    }

    #chart {
        flex: 0 0 55%;
    }

    #world_map {
        flex: 1;
    }
</style>

<body>
    <div>
        <label for="city">Search city:</label>
        <input type="text" id="city_name" name="city">
        <button type="button" id="search_city">Search</button>
    </div>
    <div id="viz">

        <div id="chart"></div>
        <div id="world_map"></div>
    </div>
    </div>

    <!-- load the d3.js library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/5.16.0/d3.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/topojson/3.0.2/topojson.min.js"></script>
    <script>

        // set the dimensions and margins of the graph
        var margin = { top: 200, right: 100, bottom: 100, left: 300 },
            width = window.innerWidth - 600,
            height = window.innerHeight - 100;

        // Register the "custom" namespace prefix for our custom elements.
        // d3.ns.prefix.custom = "https://d3js.org/namespace/custom";

        // set the ranges
        const padding = 50;
        var x = d3.scaleLinear().range([padding, width - padding]);
        var y = d3.scaleLinear().range([height - padding, padding]);

        const zoomExtent = [0.7, 32];
        const labelExtent = [1, 10];
        const baseFontSize = 15;
        const strokeWidth = 0;
        const labelOffsetY = -8;
        const initialScale = 0.7;

        d3.csv("embedding_cities.csv").then(function (data) {

            

            //Create the visible canvas and context
            var canvas = d3.select("#chart").append("canvas")
                .attr("id", "canvas")
                .attr("width", width)
                .attr("height", height);

            var context = canvas.node().getContext("2d");

            const blurCanvas = document.createElement('canvas');
            const blurContext = blurCanvas.getContext('2d');
            blurCanvas.style.webkitFilter = "blur(3px)";
            blurCanvas.width = width;
            blurCanvas.height = height;

            const labelScale = d3.scaleLinear().range(labelExtent).domain(d3.extent(data, (d) => +d.rank));
            const ex = d3.extent(data, (d) => +d.population);
            const populationRadius = d3.scaleLinear().domain(ex).range([3, 10]);
            // Scale the range of the data
            x.domain(d3.extent(data, (d) => +d.x));
            y.domain(d3.extent(data, (d) => +d.y));

            const myColor = d3.scaleSequential().domain([0, 1])
                .interpolator(d3.interpolateSpectral);

            data.forEach(function (d) {
                d.population = +d.population;
                d.radius = populationRadius(d.population);
                d.rank = +d.rank;
                d.x = +d.x;
                d.y = +d.y;
                d.cx = x(d.x);
                d.cy = y(d.y);
                d.geohash_norm = +d.geohash_norm;
                d.color = myColor(d.geohash_norm)
                d.scale = labelScale(d.rank);
            });

            const search = document.getElementById("search_city")
            search.onclick = findCoords;

            var currentK = initialScale;

            let blurScale = d3.scalePow().range([20, 10]).domain(labelExtent);

            function zoomCanvas(transform) {
                currentK = transform.k;
                window.requestAnimationFrame(function () {
                    context.clearRect(0, 0, width, height);

                    context.save();
                    context.translate(transform.x, transform.y);
                    context.scale(transform.k, transform.k);

                    // context.drawImage(blurCanvas, 0, 0);

                    redraw();

                    // context.fill();
                    context.restore();
                });
            }

            function drawBlur() {
                blurContext.clearRect(0, 0, width, height);
                context.save();
                let filter = `blur(${7}px) saturate(110%) brightness(110%) `;
                for (let d of data) {
                    drawPoint(d, blurContext);
                }
                context.filter = filter;
                context.drawImage(blurCanvas, 0, 0);
                context.restore();
                blurContext.clearRect(0, 0, width, height);
                blurContext.drawImage(canvas.node(), 0, 0);
            }

            drawBlur();

            function redraw() {
                context.drawImage(blurCanvas, 0, 0);
                for (let d of data) {
                    drawPoint(d, context);
                }

                context.fillStyle = "white";
                let fontSize = Math.max(12 / currentK, baseFontSize / (Math.pow(currentK, 1.8)));
                context.font = `${fontSize}px Open Sans`;

                for (let d of data) {
                    drawLabel(d);
                }
            }

            function drawPoint(d, context) {
                context.beginPath();
                context.arc(d.cx, d.cy, d.radius / currentK, 0, 2 * Math.PI);
                context.fillStyle = d.color;
                context.fill();
            }

            function labelXOffset(d, k) {
                // return - d.city.length * baseFontSize / 4 / k;
                let x = - context.measureText(d.city).width / 2;
                return x;
            }

            function drawLabel(d) {
                if (d.rank < 11 || d.scale <= currentK) {
                    context.fillText(d.city, d.cx + labelXOffset(d, currentK), d.cy + labelOffsetY / currentK);
                }
            }

            var root = this;
            canvas.style.position = "absolute";
            canvas.style.top = root.offsetTop + "px";
            canvas.style.left = root.offsetLeft + "px";
            context.font = "10px Open Sans"

            document.body.onkeydown = function (e) {
                if (e.keyCode == 13)
                    findCoords();
            };

            const zoom = d3.zoom()
                .scaleExtent(zoomExtent)
                .on("zoom", () => zoomCanvas(d3.event.transform));

            function findCoords() {
                const searchField = document.getElementById("city_name");
                const name = searchField.value.toLowerCase();
                var city = null;
                for (d of data) {
                    if (d.city.toLowerCase() === name) {
                        city = d;
                        break;
                    }
                }

                if (city) {
                    d3.select(context.canvas).transition().duration(750).call(
                        zoom.transform,
                        d3.zoomIdentity.translate(width / 2, height / 2).scale(10).translate(-x(city.x), -y(city.y))
                    );
                }
            }

            d3.select(context.canvas).call(zoom);
            zoom.scaleTo(canvas, initialScale);

            redraw()

            function drawMap() {
                const svg = d3.select("#world_map").append("svg").attr("width", "100%").attr("height", "100%");

                var projection = d3.geoMercator()
                    .center([100, -20])
                    .scale(100)

                var path = d3.geoPath()
                    .projection(projection);

                var g = svg.append("g");

                const bounding = document.getElementById('world_map').getBoundingClientRect()
                const geoX = d3.scaleLinear().range([0, bounding.width]).domain(d3.extent(data, d=>+d.g_x));
                const geoY = d3.scaleLinear().range([bounding.height, 0]).domain(d3.extent(data, d=>+d.g_y));

                // load and display the World
                d3.json("https://cdn.jsdelivr.net/npm/world-atlas@2/countries-110m.json").then(function (topology) {
                    g.selectAll("path")
                        .data(topojson.feature(topology, topology.objects.countries).features)
                        .enter().append("path")
                        .attr("d", path);

                    g.selectAll("circle")
                        .data(data)
                        .join("circle")
                        .attr("cx", function(d){
                          var p = projection([+d.g_x, +d.g_y]);
                            return p[0];
                        } )
                        .attr("cy", d => projection([+d.g_x, +d.g_y])[1])
                        .attr("r", 2)
                        .attr("fill", d=>d.color)
                });
            }

            drawMap();

        });


    </script>
</body>